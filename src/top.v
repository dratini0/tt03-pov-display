/* Generated by Yosys 0.23 (git sha1 7ce5011c24b) */

module _pulser(rst, hall_in, advance, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$1  = 0;
  wire [10:0] \$1 ;
  wire [11:0] \$11 ;
  wire [10:0] \$12 ;
  wire [11:0] \$14 ;
  wire [10:0] \$16 ;
  wire [10:0] \$17 ;
  wire \$3 ;
  wire [10:0] \$5 ;
  wire [10:0] \$6 ;
  wire [10:0] \$8 ;
  wire [10:0] \$9 ;
  reg [9:0] _comparison_signal = 10'h000;
  reg [9:0] \_comparison_signal$next ;
  reg [9:0] _counter = 10'h000;
  reg [9:0] \_counter$next ;
  reg [9:0] _last_total = 10'h000;
  reg [9:0] \_last_total$next ;
  output advance;
  wire advance;
  input clk;
  wire clk;
  wire hall_edge_in_;
  wire hall_edge_out;
  input hall_in;
  wire hall_in;
  input rst;
  wire rst;
  assign \$9  = _counter + 1'h1;
  assign \$12  = _comparison_signal + 6'h20;
  assign \$14  = \$12  - _last_total;
  assign \$17  = _comparison_signal + 6'h20;
  always @(posedge clk)
    _counter <= \_counter$next ;
  assign \$1  = _comparison_signal + 6'h20;
  always @(posedge clk)
    _last_total <= \_last_total$next ;
  always @(posedge clk)
    _comparison_signal <= \_comparison_signal$next ;
  assign \$3  = \$1  >= _last_total;
  assign \$6  = _counter + 1'h1;
  hall_edge hall_edge (
    .clk(clk),
    .in_(hall_edge_in_),
    .out(hall_edge_out),
    .rst(rst)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    (* full_case = 32'd1 *)
    casez (hall_edge_out)
      1'h1:
          \_counter$next  = 10'h000;
      default:
          \_counter$next  = \$6 [9:0];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    \_last_total$next  = _last_total;
    casez (hall_edge_out)
      1'h1:
          \_last_total$next  = \$9 [9:0];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    (* full_case = 32'd1 *)
    casez (hall_edge_out)
      1'h1:
          \_comparison_signal$next  = 10'h000;
      default:
          (* full_case = 32'd1 *)
          casez (advance)
            1'h1:
                \_comparison_signal$next  = \$14 [9:0];
            default:
                \_comparison_signal$next  = \$17 [9:0];
          endcase
    endcase
  end
  assign \$5  = \$6 ;
  assign \$8  = \$9 ;
  assign \$11  = \$14 ;
  assign \$16  = \$17 ;
  assign advance = \$3 ;
  assign hall_edge_in_ = hall_in;
endmodule

module controller(rst, hall_in, advance, clk);
  wire _pulser_advance;
  wire _pulser_hall_in;
  output advance;
  wire advance;
  input clk;
  wire clk;
  input hall_in;
  wire hall_in;
  input rst;
  wire rst;
  _pulser _pulser (
    .advance(_pulser_advance),
    .clk(clk),
    .hall_in(_pulser_hall_in),
    .rst(rst)
  );
  assign advance = _pulser_advance;
  assign _pulser_hall_in = hall_in;
endmodule

module cs_edge(rst, in_, out, clk);
  wire \$1 ;
  wire \$3 ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  reg last_in = 1'h0;
  wire \last_in$next ;
  output out;
  wire out;
  input rst;
  wire rst;
  assign \$1  = ~ last_in;
  assign \$3  = in_ & \$1 ;
  always @(posedge clk)
    last_in <= \last_in$next ;
  assign out = \$3 ;
  assign \last_in$next  = in_;
endmodule

module display(rst, cs_n, sck, mosi, hall_in, leds, clk);
  wire \$2 ;
  input clk;
  wire clk;
  wire controller_advance;
  wire controller_hall_in;
  input cs_n;
  wire cs_n;
  wire \cs_n$1 ;
  input hall_in;
  wire hall_in;
  output [7:0] leds;
  wire [7:0] leds;
  wire mem_advance;
  wire [7:0] mem_in_;
  wire [7:0] mem_out;
  wire mem_write;
  input mosi;
  wire mosi;
  input rst;
  wire rst;
  input sck;
  wire sck;
  wire spi_cs_n;
  wire [7:0] spi_data;
  wire spi_mosi;
  wire spi_sck;
  wire spi_we;
  assign \$2  = controller_advance | spi_we;
  controller controller (
    .advance(controller_advance),
    .clk(clk),
    .hall_in(controller_hall_in),
    .rst(rst)
  );
  mem mem (
    .advance(mem_advance),
    .clk(clk),
    .in_(mem_in_),
    .out(mem_out),
    .rst(rst),
    .write(mem_write)
  );
  spi spi (
    .clk(clk),
    .cs_n(spi_cs_n),
    .data(spi_data),
    .mosi(spi_mosi),
    .rst(rst),
    .sck(spi_sck),
    .we(spi_we)
  );
  assign leds = mem_out;
  assign mem_advance = \$2 ;
  assign mem_write = spi_we;
  assign mem_in_ = spi_data;
  assign \cs_n$1  = cs_n;
  assign controller_hall_in = hall_in;
  assign spi_mosi = mosi;
  assign spi_sck = sck;
  assign spi_cs_n = cs_n;
endmodule

module dratini0_pov_display_top(io_out, io_in);
  wire display_clk;
  wire display_cs_n;
  wire display_hall_in;
  wire [7:0] display_leds;
  wire display_mosi;
  wire display_rst;
  wire display_sck;
  input [7:0] io_in;
  wire [7:0] io_in;
  output [7:0] io_out;
  wire [7:0] io_out;
  display display (
    .clk(display_clk),
    .cs_n(display_cs_n),
    .hall_in(display_hall_in),
    .leds(display_leds),
    .mosi(display_mosi),
    .rst(display_rst),
    .sck(display_sck)
  );
  assign io_out = display_leds;
  assign display_hall_in = io_in[5];
  assign display_mosi = io_in[4];
  assign display_sck = io_in[3];
  assign display_cs_n = io_in[2];
  assign display_rst = io_in[1];
  assign display_clk = io_in[0];
endmodule

module hall_edge(rst, in_, out, clk);
  wire \$1 ;
  wire \$3 ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  reg last_in = 1'h0;
  wire \last_in$next ;
  output out;
  wire out;
  input rst;
  wire rst;
  assign \$1  = ~ last_in;
  assign \$3  = in_ & \$1 ;
  always @(posedge clk)
    last_in <= \last_in$next ;
  assign out = \$3 ;
  assign \last_in$next  = in_;
endmodule

module mem(rst, in_, write, advance, out, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$2  = 0;
  reg [191:0] _state = 192'h000000000000000000000000000000000000000000000000;
  reg [191:0] \_state$next ;
  input advance;
  wire advance;
  input clk;
  wire clk;
  input [7:0] in_;
  wire [7:0] in_;
  output [7:0] out;
  wire [7:0] out;
  input rst;
  wire rst;
  input write;
  wire write;
  always @(posedge clk)
    _state <= \_state$next ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    \_state$next  = _state;
    casez (advance)
      1'h1:
        begin
          \_state$next [191:8] = _state[183:0];
          (* full_case = 32'd1 *)
          casez (write)
            1'h1:
                \_state$next [7:0] = in_;
            default:
                \_state$next [7:0] = out;
          endcase
        end
    endcase
  end
  assign out = _state[191:184];
endmodule

module sck_edge(rst, in_, out, clk);
  wire \$1 ;
  wire \$3 ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  reg last_in = 1'h0;
  wire \last_in$next ;
  output out;
  wire out;
  input rst;
  wire rst;
  assign \$1  = ~ last_in;
  assign \$3  = in_ & \$1 ;
  always @(posedge clk)
    last_in <= \last_in$next ;
  assign out = \$3 ;
  assign \last_in$next  = in_;
endmodule

module spi(rst, cs_n, sck, mosi, data, we, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$3  = 0;
  wire \$1 ;
  wire \$10 ;
  wire \$12 ;
  wire [9:0] \$14 ;
  wire [9:0] \$15 ;
  wire \$17 ;
  wire \$19 ;
  wire \$21 ;
  wire \$23 ;
  wire \$3 ;
  wire \$5 ;
  wire [3:0] \$7 ;
  wire [3:0] \$8 ;
  reg [2:0] _bit_index = 3'h0;
  reg [2:0] \_bit_index$next ;
  input clk;
  wire clk;
  wire cs_edge_in_;
  wire cs_edge_out;
  input cs_n;
  wire cs_n;
  output [7:0] data;
  reg [7:0] data = 8'h00;
  reg [7:0] \data$next ;
  input mosi;
  wire mosi;
  input rst;
  wire rst;
  input sck;
  wire sck;
  wire sck_edge_in_;
  wire sck_edge_out;
  output we;
  reg we = 1'h0;
  reg \we$next ;
  assign \$10  = ~ cs_n;
  assign \$12  = \$10  & sck_edge_out;
  assign \$15  = { data, 1'h0 } + mosi;
  assign \$17  = ~ cs_n;
  assign \$1  = ~ cs_n;
  assign \$19  = \$17  & sck_edge_out;
  assign \$21  = _bit_index == 3'h7;
  assign \$23  = \$19  & \$21 ;
  always @(posedge clk)
    _bit_index <= \_bit_index$next ;
  always @(posedge clk)
    data <= \data$next ;
  always @(posedge clk)
    we <= \we$next ;
  assign \$3  = ~ cs_n;
  assign \$5  = \$3  & sck_edge_out;
  assign \$8  = _bit_index + 1'h1;
  cs_edge cs_edge (
    .clk(clk),
    .in_(cs_edge_in_),
    .out(cs_edge_out),
    .rst(rst)
  );
  sck_edge sck_edge (
    .clk(clk),
    .in_(sck_edge_in_),
    .out(sck_edge_out),
    .rst(rst)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \_bit_index$next  = _bit_index;
    casez (\$5 )
      1'h1:
          \_bit_index$next  = \$8 [2:0];
    endcase
    casez (cs_edge_out)
      1'h1:
          \_bit_index$next  = 3'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \data$next  = data;
    casez (\$12 )
      1'h1:
          \data$next  = \$15 [7:0];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    \we$next  = \$23 ;
    casez (rst)
      1'h1:
          \we$next  = 1'h0;
    endcase
  end
  assign \$7  = \$8 ;
  assign \$14  = \$15 ;
  assign cs_edge_in_ = \$1 ;
  assign sck_edge_in_ = sck;
endmodule

